### 1. 동시성 문제의 유형

#### 1.1 갱신 손실(Lost Update)

- 여러 트랜잭션이 동시에 동일한 데이터 수정할 때 발생함.
    
- 하나의 트랜잭션이 수정한 내용을 다른 트랜잭션이 덮어씀.
    
- 결과적으로 하나의 업데이트가 사라짐.
    

#### 1.2 부정확한 읽기(Dirty Read)

- 트랜잭션 A가 데이터를 수정하고 커밋하기 전에, 트랜잭션 B가 그 데이터를 읽는 경우 발생함.
    
- 트랜잭션 A가 롤백되면, 트랜잭션 B는 잘못된 데이터를 읽은 셈이 됨.
    

#### 1.3 비정상적인 반복 읽기(Unrepeatable Read)

- 트랜잭션 A가 데이터를 읽은 후, 같은 데이터를 다시 읽을 때 값이 달라짐.
    
- 다른 트랜잭션이 중간에 데이터를 수정하고 커밋했기 때문임.
    

#### 1.4 팬텀 리드(Phantom Read)

- 트랜잭션 A가 조건에 맞는 데이터를 조회한 후, 트랜잭션 B가 새로운 데이터를 삽입하거나 삭제하는 경우 발생함.
    
- 트랜잭션 A가 다시 같은 조건으로 조회했을 때 결과가 달라짐.
    

---

### 2. 동시성 문제 해결 방법

#### 2.1 트랜잭션 격리 수준 (Transaction Isolation Levels)

1. **Read Uncommitted**
    
    - 커밋되지 않은 데이터 읽는 거 허용함.
        
    - Dirty Read 발생 가능.
        
    - 성능은 빠름, 데이터 일관성은 낮음.
        
2. **Read Committed**
    
    - 커밋된 데이터만 읽게 함.
        
    - Dirty Read 방지됨.
        
    - Unrepeatable Read는 여전히 발생할 수 있음.
        
3. **Repeatable Read**
    
    - 트랜잭션 동안 읽은 데이터는 바뀌지 않게 보장함.
        
    - Unrepeatable Read 방지됨.
        
    - 팬텀 리드는 여전히 발생 가능.
        
4. **Serializable**
    
    - 가장 높은 격리 수준.
        
    - 트랜잭션을 직렬적으로 실행한 것처럼 처리함.
        
    - 모든 동시성 문제 예방 가능.
        
    - 성능은 느릴 수 있음.
        

#### 2.2 락(Lock)

- 특정 데이터를 트랜잭션이 잠그고 다른 트랜잭션이 접근 못하게 막음.
    
- 대표적으로 **행 단위 잠금(Row-level)**, **테이블 단위 잠금(Table-level)** 있음.
    
- 행 단위는 더 세밀하게 제어 가능해서 성능에 유리할 수 있음.
    

---

### 3. 동시성 제어 알고리즘

#### 3.1 2단계 잠금 규약 (2PL, Two-Phase Locking)

- 잠금 과정이 두 단계로 진행됨.
    
    1. 증가 단계(Growing): 잠금 요청만 가능.
        
    2. 축소 단계(Shrinking): 잠금 해제만 가능.
        
- 갱신 손실 방지됨.
    
- 단점: 데드락 발생 가능.
    

#### 3.2 다중 버전 동시성 제어 (MVCC)

- 각 트랜잭션이 데이터의 버전을 따로 가지게 함.
    
- Dirty Read, Unrepeatable Read 방지 가능.
    
- PostgreSQL, MySQL InnoDB 등에서 사용함.
    

---

### 4. 결론

- DB 동시성 문제는 동시 실행 환경에서 필연적으로 고려해야 할 문제임.
    
- 트랜잭션 격리 수준, 락, 동시성 제어 알고리즘 등을 통해 해결 가능.
    
- 성능과 데이터 일관성 사이의 균형이 중요함.