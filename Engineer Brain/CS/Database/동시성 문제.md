**DB 동시성 문제**는 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제로, 여러 사용자나 시스템이 동시에 데이터베이스에 접근하면서 데이터의 일관성(consistency)이나 정확성을 보장하는 것이 중요해져. 이 문제는 **동시성 제어(concurrency control)**와 관련이 있으며, 이를 잘 처리하지 않으면 데이터베이스의 **무결성(integrity)**이 손상될 수 있어.

### 1. **동시성 문제의 유형**

DB에서 동시성 문제는 주로 **갱신 손실(Lost Update)**, **부정확한 읽기(Dirty Read)**, **비정상적인 반복 읽기(Unrepeatable Read)**, **팬텀 리드(Phantom Read)** 등으로 나누어볼 수 있어. 각각의 문제를 설명할게.

#### 1.1 **갱신 손실(Lost Update)**

- 여러 트랜잭션이 동일한 데이터를 동시에 수정할 때 발생해.
- 예를 들어, 트랜잭션 A와 B가 동시에 같은 데이터를 수정하는데, 하나가 끝날 때 다른 트랜잭션이 덮어쓰는 상황이 발생할 수 있어.
- 결과적으로 **하나의 업데이트가 손실되는** 문제.

#### 1.2 **부정확한 읽기(Dirty Read)**

- 트랜잭션 A가 데이터를 수정하고 커밋하기 전에 트랜잭션 B가 그 데이터를 읽을 때 발생해.
- 트랜잭션 A가 롤백되면, 트랜잭션 B는 **잘못된 데이터를 읽은** 셈이 돼.
- **실제로 존재하지 않은 데이터를 읽는 문제**.

#### 1.3 **비정상적인 반복 읽기(Unrepeatable Read)**

- 트랜잭션 A가 데이터를 읽은 후, 같은 데이터를 다시 읽을 때 다른 값이 반환되는 문제야.
- 트랜잭션 B가 트랜잭션 A의 데이터 값을 수정하고 커밋하면, 트랜잭션 A는 데이터를 처음 읽은 후 다시 읽을 때 다른 값을 보게 되지.
- **동일한 쿼리가 서로 다른 결과를 반환**하는 상황.

#### 1.4 **팬텀 리드(Phantom Read)**

- 트랜잭션 A가 특정 조건에 맞는 데이터를 조회하는 동안, 트랜잭션 B가 새로운 데이터를 삽입하거나 삭제하는 경우 발생해.
- 트랜잭션 A가 처음 데이터를 조회할 때와 두 번째 조회 때 조건에 맞는 데이터가 달라지는 상황이 생겨.
- 예를 들어, 트랜잭션 A가 특정 조건에 맞는 데이터를 10개 조회했는데, 트랜잭션 B가 그 사이에 새로운 데이터를 삽입하여 조회된 데이터의 수가 달라질 수 있어.
- **쿼리 실행 후 조건을 만족하는 데이터의 개수가 달라지는 문제**.

### 2. **동시성 문제를 해결하는 방법**

동시성 문제를 해결하려면 **트랜잭션 격리 수준(Transaction Isolation Level)**을 설정하는 것이 주요 방법이야. DBMS에서는 여러 격리 수준을 제공하는데, 각 수준마다 동시성 문제에 대한 처리 방법이 다르고 성능에 영향을 미쳐.

#### 2.1 **트랜잭션 격리 수준 (Transaction Isolation Levels)**

1. **Read Uncommitted (읽기 미완료)**
    
    - **가장 낮은 격리 수준**으로, 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있어.
    - **부정확한 읽기(Dirty Read)**를 허용함.
    - **성능**은 좋지만, **데이터 일관성**은 보장되지 않아.
2. **Read Committed (읽기 완료)**
    
    - **커밋된 데이터**만 읽을 수 있도록 보장.
    - **부정확한 읽기(Dirty Read)**는 방지되지만, 여전히 **비정상적인 반복 읽기(Unrepeatable Read)**는 발생할 수 있음.
    - **일관성**은 일정 수준 보장되며, **성능**도 괜찮아.
3. **Repeatable Read (반복 가능한 읽기)**
    - 트랜잭션이 읽은 데이터는 **트랜잭션이 끝날 때까지** 다른 트랜잭션에 의해 수정되지 않도록 보장.
    - **비정상적인 반복 읽기(Unrepeatable Read)**를 방지할 수 있음.
    - **팬텀 리드(Phantom Read)**는 여전히 발생할 수 있음.
4. **Serializable (직렬화 가능)**
    
    - 가장 높은 격리 수준으로, 트랜잭션이 실행될 때 다른 트랜잭션의 영향을 전혀 받지 않도록 보장.
    - 모든 트랜잭션은 **직렬화된 순서**로 처리되며, **갱신 손실**이나 **비정상적인 반복 읽기**, **팬텀 리드**가 발생하지 않음.
    - 성능은 다소 떨어질 수 있지만, **완전한 일관성**을 제공.

#### 2.2 **락(Lock)**

- **락**을 사용하여 동시성 문제를 방지할 수 있어. 특정 데이터를 변경하려는 트랜잭션이 있을 때, 다른 트랜잭션이 그 데이터를 변경하지 못하도록 **잠금을 설정**함.
- 예를 들어, **행 단위 잠금(Row-level Locking)**이나 **테이블 단위 잠금(Table-level Locking)**을 설정할 수 있음.
    - 행 단위 잠금은 더 세밀하게 잠금을 설정할 수 있어 성능 면에서 더 유리할 수 있어.

### 3. **동시성 제어 알고리즘**

DBMS는 동시성 문제를 해결하기 위해 다양한 **동시성 제어 알고리즘**을 사용해. 그중 대표적인 것들이 있어.

#### 3.1 **2단계 잠금 규약 (2PL, Two-Phase Locking)**

- 트랜잭션이 데이터를 잠글 때 **두 단계**로 나눠서 잠금을 관리하는 방식.
    1. **증가 단계(Growing Phase)**: 잠금을 요청하고, 변경 작업을 시작할 수 있음.
    2. **축소 단계(Shrinking Phase)**: 잠금을 해제하며 변경 작업을 끝냄.
- **2PL**은 **갱신 손실**을 방지할 수 있지만, **데드락(Deadlock)**을 발생시킬 수 있음.

#### 3.2 **다단계 타임스탬프 규약 (Multiversion Concurrency Control, MVCC)**

- 각 트랜잭션이 자신만의 버전을 만들도록 하여, 데이터의 여러 버전을 동시에 관리함.
- **Dirty Read**를 방지하고, **비정상적인 반복 읽기**를 해결할 수 있어.
- 주로 **PostgreSQL**이나 **MySQL InnoDB**에서 사용함.

### 4. **결론**

동시성 문제는 여러 트랜잭션이 동시에 처리되는 환경에서 발생할 수 있는 중요한 문제야. 이를 해결하기 위해서는 트랜잭션 격리 수준을 적절히 설정하거나, **락**을 사용하는 방식 등으로 **데이터베이스의 일관성**을 보장해야 해. 각 방법은 **성능**과 **일관성** 사이의 균형을 맞추는 중요한 요소야.